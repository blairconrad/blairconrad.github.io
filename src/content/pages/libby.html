<html>

<head>
    <title>Libby</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
    <link rel="icon" type="image/x-icon" href="/images/libraryhippo-icon-64.ico" />
    <style>
        th:first-child,
        td:first-child {
            text-align: right;

            /* otherwise it fetches up against the next column */
            padding-right: 2em;
        }

        table {
            table-layout: auto;
        }
    </style>
</head>

<body>
    <div id="content" />
    <script async>
        const proxyBase = 'https://libby-proxy.blairconrad.workers.dev/proxy?proxyUrl='
        const overdriveUrlBase = 'https://sentry-read.svc.overdrive.com/'
        const bearerTokenKey = 'libby.bearer.token';
        window.onload = async (event) => {

            const locationUrl = new URL(window.location.href);

            if (locationUrl.searchParams.has('reset')) {
                window.localStorage.removeItem(bearerTokenKey);
            }

            var bearer = window.localStorage.getItem(bearerTokenKey);
            if (bearer) {
                loadContent(bearer);
            } else {
                const codeInput = document.createElement('input');
                codeInput.setAttribute('autocomplete', 'off');
                codeInput.setAttribute('autofocus', 'autofocus');
                codeInput.setAttribute('id', 'code');
                codeInput.setAttribute('maxlength', 8);
                codeInput.setAttribute('name', 'code');
                codeInput.setAttribute('pattern', '[0-9]{8}');
                codeInput.setAttribute('placeholder', '12345678');
                codeInput.setAttribute('required', 'required');
                codeInput.setAttribute('size', '8');
                codeInput.setAttribute('title', '8-digit one-time Libby code');
                codeInput.setAttribute('type', 'text');

                const codeSubmit = document.createElement('input');
                codeSubmit.setAttribute('type', 'submit');
                codeSubmit.setAttribute('value', 'Submit');

                const codeForm = document.createElement('form');
                codeForm.appendChild(codeInput);
                codeForm.appendChild(codeSubmit);
                codeForm.addEventListener('submit', cloneCode);

                const codeText = document.createElement('p');
                codeText.innerHTML = `
You don't appear to have registered your Libby Account. Enter an
8-digit code <a href="https://help.libbyapp.com/en-us/6070.htm">you can get from another logged-in
Libby account</a>.
`;

                const contentNode = document.getElementById('content');
                contentNode.replaceChildren(codeText, codeForm);
            }
        };

        async function loadContent(bearer) {
            const contentNode = document.getElementById('content');
            contentNode.innerHTML = 'loading&hellip;';

            const syncPath = 'chip/sync';
            const syncUrl = proxyBase + encodeURI(overdriveUrlBase + syncPath);
            const response = await fetch(syncUrl, { headers: { 'Authorization': 'Bearer ' + bearer } });
            const syncData = await response.json();
            const cards = getCards(syncData);
            const loans = getLoans(syncData);
            const holds = getHolds(syncData);
            const readyHolds = holds.filter(h => h.isReady).sort(sortKey(h => h.expireDate));
            const pendingHolds = holds.filter(h => !h.isReady).sort(sortKey(h => h.estimatedWaitDays));

            const lines = html(loans, readyHolds, pendingHolds, cards).join('\n');
            contentNode.innerHTML = lines;
        }

        async function cloneCode(e) {
            const chipPath = 'chip?client=dewey';
            const clonePath = 'chip/clone/code';

            e.preventDefault();

            const chipUrl = proxyBase + encodeURI(overdriveUrlBase + chipPath);
            var chipResponse = await fetch(chipUrl, { method: 'POST' });
            var chipData = await chipResponse.json();
            var bearer = chipData.identity;

            const code = new FormData(e.target).get('code');

            const cloneUrl = encodeURI(proxyBase + overdriveUrlBase + clonePath);
            const cloneResponse = await fetch(
                cloneUrl,
                {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Authorization': `Bearer ${bearer}`,
                        'Content-Type': 'application/json',
                    },
                    body: `{"code":"${code}"}`,
                });
            if (cloneResponse.ok) {

                chipResponse = await fetch(chipUrl, { method: 'POST', headers: { 'Authorization': `Bearer ${bearer}` } });
                if (chipResponse.ok) {
                    chipData = await chipResponse.json();
                    bearer = chipData.identity;

                    window.localStorage.setItem(bearerTokenKey, bearer);
                    loadContent(bearer);
                }
            }
        }

        function getCards(data) {
            cards = Object();
            for (card of data.cards) {
                cards[card.cardId] = card;
            }
            return cards;
        }

        function getLoans(data) {
            return data.loans.map(parseLoan);
        }

        function parseLoan(loanData) {
            loanData.expireDate = new Date(loanData.expireDate);
            return loanData;
        }

        function getHolds(data) {
            return data.holds.map(parseHold);
        }

        function parseHold(holdData) {
            var notes = ''
            if (holdData.detailedSeries) {
                const seriesName = holdData.detailedSeries.seriesName;
                const readingOrder = holdData.detailedSeries.readingOrder;
                if (seriesName && readingOrder) {
                    notes += `${seriesName} #${readingOrder}`
                }
            }
            if (holdData.expireDate) {
                holdData.isReady = true;
                holdData.expireDate = new Date(holdData.expireDate);
            }
            if (!holdData.estimatedWaitDays) {
                holdData.estimatedWaitDays = 0;
            }
            if (!holdData.ownedCopies) {
                holdData.estimatedWaitDays = Infinity;
                if (notes) {
                    notes += '<br>';
                }
                notes += 'no more copies';
            }
            holdData.notes = notes ? notes : '&nbsp;';

            return holdData;
        }

        function html(loans, readyHolds, pendingHolds, cards) {
            lines = []
            if (loans.length) {
                startSection(lines, 'Loans');
                startTable(lines, '&#x23f3; Expires', '&#x1f4da; Title', '&#x1FAAA; Card');
                for (loan of loans) {
                    addRow(lines, formatExpireDate(loan.expireDate), loan.title, cards[loan.cardId].cardName);
                }
                endTable(lines);

                endSection(lines);
            }
            if (readyHolds.length) {
                startSection(lines, 'Ready Holds');
                startTable(lines, '&#x23f3; Expires', '&#x1f4da; Title', '&#x1FAAA; Card', '&#x1f3b6; Notes');
                for (hold of readyHolds) {
                    addRow(lines, formatExpireDate(hold.expireDate), hold.title, cards[hold.cardId].cardName, hold.notes);
                }
                endTable(lines);

                endSection(lines);
            }
            if (pendingHolds.length) {
                startSection(lines, 'Pending Holds');
                startTable(lines, '&#x1f4c5; Days to Wait', '&#x1f4da; Title', '&#x1f4dd; Author', '&#x1f3b6; Notes');
                for (hold of pendingHolds) {
                    addRow(lines, formatWaitDays(hold.estimatedWaitDays), hold.title, hold.firstCreatorName, hold.notes);
                }
                endTable(lines);

                endSection(lines);
            }
            return lines;
        }

        function startSection(lines, text) {
            lines.push(`<div id='${slug(text)}'>`);
            lines.push(`<h2>${text}</h2>`);
        }

        function endSection(lines) {
            lines.push('</div>');
        }

        function startTable(lines, ...columnHeaders) {
            lines.push('<table>')
            lines.push('  <thead>')
            lines.push('    <tr>')
            for (h of columnHeaders) {
                lines.push(`      <th>${h}</th>`)
            }
            lines.push('  </thead>')
            lines.push('  <tbody>')
        }


        function addRow(lines, ...cellValues) {
            var text = '    <tr>';
            for (v of cellValues) {
                text += `<td>${v}</td>`;
            }
            text += '</tr>';
            lines.push(text);
        }

        function endTable(lines) {
            lines.push('</table>');
        }

        function formatExpireDate(date) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = [
                'January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'
            ];

            const dayPart = days[date.getDay()];
            const timePart =
                date.getHours().toString().padStart(2, '0') + ':' +
                date.getMinutes().toString().padStart(2, '0')

            const now = new Date();
            const daysFromNow = (date - now) / 86_400_000;
            const middlePart = daysFromNow >= 6
                ? ' ' + date.getDate().toString().padStart(2, '0') + ' ' + months[date.getMonth()] + ' '
                : ' ';
            const formattedDate = dayPart + middlePart + timePart;
            return `<span title="${date}">${formattedDate}</span>`;
        }

        function formatWaitDays(waitDays) {
            switch (waitDays) {
                case 0:
                    return '&nbsp;'
                case Infinity:
                    return '&infin;';
                default:
                    return waitDays;
            }
        }

        function sortKey(keyFunc) {
            return function (a, b) {
                const aKey = keyFunc(a);
                const bKey = keyFunc(b);
                return aKey < bKey
                    ? -1 : aKey == bKey
                        ? 0
                        : 1;
            }
        }

        function slug(text) {
            return text.toLowerCase().replace(' ', '-')
        }

    </script>
</body>

</html>